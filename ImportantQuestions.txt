Important Questions
_____________________________________________________________________
Q1 = What is Segmentation Fault ?

		Segmentation fault is a specific kind of error caused by accessing memory that “does not belong to you.” It’s a helper mechanism that keeps you from corrupting the memory and introducing hard-to-debug memory bugs. Whenever you get a segfault you know you are doing something wrong with memory – accessing variable that has already been freed, writing to a read-only portion of the memory, etc. Segmentation fault is essentially the same in most languages that let you mess with the memory management, there is no principial difference between segfaults in C and C++.

		There are many ways to get a segfault, at least in the lower-level languages such as C(++). A common way to get a segfault is to dereference a null pointer:

		int *p = NULL;
		*p = 1;

		Another segfault happens when you try to write to a portion of memory that was marked as read-only:

		char *str = "Foo"; // Compiler marks the constant string as read-only
		*str = 'b'; // Which means this is illegal and results in a segfault

		Dangling pointer points to a thing that does not exist any more, like here:

		char *p = NULL;
		{
		    char c;
		    p = &c;
		}
		// Now p is dangling

		The pointer p dangles because it points to character variable c that ceased to exist after the block ended. And when you try to dereference dangling pointer (like *p='A'), you would probably get a segfault


***********************************************************************
2). Return array from function in C
_______________________________________
C programming does not allow to return an entire array as an argument to a function. However, you can return a pointer to an array by specifying the array's name without an index.

If you want to return a single-dimension array from a function, you would have to declare a function returning a pointer as in the following example 

int * myFunction() {
   .
   .
   .
}

Second point to remember is that C does not advocate to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable.

**************************************************************************
3)	DECLARATION OF Dynamic 2d array
__________________________________________
A dynamic 2D array is basically an array of pointers to arrays. You should initialize it using a loop, like this:

int** ary = new int*[rowCount];
for(int i = 0; i < rowCount; ++i)
    ary[i] = new int[colCount];
